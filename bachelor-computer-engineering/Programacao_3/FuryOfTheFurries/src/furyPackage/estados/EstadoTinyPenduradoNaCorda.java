/* Generated by Together */

package furyPackage.estados;

import java.util.Hashtable;
import furyPackage.Corda;
import furyPackage.Suportavel;
import furyPackage.Tiny;
import furyPackage.collisionPackage.Colidivel;
import furyPackage.collisionPackage.PararTinyNaCorda;
import jge2d.ResultadoColisao;
import jge2d.jogo.movimentos.MovimentoTinyPenduradoNaCorda;

/**
 * Define o comportamento do Tiny com um movimento pendurado na corda
 */
public final class EstadoTinyPenduradoNaCorda extends EstadoTinyComMovimento {

    private SubEstadoPendurado[] subEstados = new SubEstadoPendurado[] {new SubEstadoPenduradoMeio(this), new SubEstadoPenduradoEsquerdo(this), new SubEstadoPenduradoDireito(this), new SubEstadoPenduradoCima(this), new SubEstadoPenduradoBaixo(this)};
    private int subEstadoActual = SubEstadoPendurado.MEIO;
    private Hashtable tabelaColisoes = new Hashtable();

    private double tetha;

    public EstadoTinyPenduradoNaCorda(Tiny heroi, MovimentoTinyPenduradoNaCorda movimento) {
        super(heroi, movimento);
        PararTinyNaCorda pararTinyNaCorda = new PararTinyNaCorda();
        tabelaColisoes.put(new Integer(ResultadoColisao.COLISAO_POR_DENTRO), pararTinyNaCorda);
        tabelaColisoes.put(new Integer(ResultadoColisao.COLISAO_POR_BAIXO), pararTinyNaCorda);
        tabelaColisoes.put(new Integer(ResultadoColisao.COLISAO_POR_CIMA), pararTinyNaCorda);
        tabelaColisoes.put(new Integer(ResultadoColisao.COLISAO_POR_DIREITA), pararTinyNaCorda);
        tabelaColisoes.put(new Integer(ResultadoColisao.COLISAO_POR_ESQUERDA), pararTinyNaCorda);
    }

    /**
     * Puxa a corda para cima
     */
    public void moverCima(long tempo){
        subEstados[subEstadoActual].moverCima(tempo);
    }

    /**
     * Puxa a corda para baixo
     */
    public void moverBaixo(long tempo){
        subEstados[subEstadoActual].moverBaixo(tempo);
    }

    /**
     * Balança o Tiny para a direita
     */
    public void moverDireita(long tempo){
        subEstados[subEstadoActual].moverDireita(tempo);
    }

    /**
     * Balança o Tiny para a esquerda
     */
    public void moverEsquerda(long tempo){
        subEstados[subEstadoActual].moverEsquerda(tempo);
    }

    public void parar(long tempo){
        getThisMovimento().setAproximacaoCentro(MovimentoTinyPenduradoNaCorda.SEM_VARIACAO_DISTANCIA);
        getThisMovimento().setSentidoRotacao(MovimentoTinyPenduradoNaCorda.SEM_ROTACAO);
        getHeroi().getNivel().adicionarRemovivel(getHeroi());
    }

    public MovimentoTinyPenduradoNaCorda getThisMovimento() {
        return (MovimentoTinyPenduradoNaCorda) getMovimento();
    }

    /**
     * Trata a colisão com objectos de suporte do tiny, e passa o tiny para o estado suportado atribuíndo-lhe a plataforma que o suporta
     */
    public void trataColisao(Suportavel plataforma, ResultadoColisao resultado) {
        ((Colidivel)tabelaColisoes.get(new Integer(resultado.resultadoObjecto1.tipoColisao))).trataColisao(resultado);
    }

    /**
     * diagonalDireita
     *
     * @param tempo long
     */
    public void diagonalDireita(long tempo) {
        moverCima(tempo);
        moverDireita(tempo);
    }

    /**
     * diagonalEsquerda
     *
     * @param tempo long
     */
    public void diagonalEsquerda(long tempo) {
        moverCima(tempo);
        moverEsquerda(tempo);
    }

    /**
     * iterar
     *
     * @param tempo long
     */
    public void iterar(long tempo) {
        tetha = Math.toDegrees(Math.atan2(getThisMovimento().getPosicaoCentro().getY() - getThisMovimento().getUltimaPosicao().getY(),
                                                 getThisMovimento().getUltimaPosicao().getX() - getThisMovimento().getPosicaoCentro().getX()));
        if (tetha == 0)
            subEstadoActual = SubEstadoPendurado.CIMA;
        else if (360 + tetha < getHeroi().getAnguloMinimo() - 5 || 360 + tetha > getHeroi().getAnguloMaximo() + 5)
            getHeroi().getCorda().desenganchar(tempo);
        else if (360 + tetha < getHeroi().getAnguloMinimo())
            subEstados[subEstadoActual].pararEsquerda(tempo);
        else if (360 + tetha > getHeroi().getAnguloMaximo())
            subEstados[subEstadoActual].pararDireita(tempo);
        else if (getHeroi().getMovimentoActual().getUltimaPosicao().distance(getHeroi().getCorda().getSprite().getMovimento().getUltimaPosicao()) >= Corda.COMPRIMENTO_MAXIMO)
            subEstados[subEstadoActual].pararBaixo(tempo);
        else
            subEstadoActual = SubEstadoPendurado.MEIO;
    }

    public int getSubEstadoActual() {
        return subEstadoActual;
    }

    public SubEstadoPendurado getSubEstado(int subEstado) {
        return subEstados[subEstado];
    }

    public void mudarSubEstado(int novoSubEstado) {
        subEstadoActual = novoSubEstado;
    }

    public void desSuportar(long tempo) {
    }
}
